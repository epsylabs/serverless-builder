{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"About","text":"serverless-builder <p>serverless-builder is Python (3.8+) interface to easily generate serverless.yml file.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>full support for all features provided by serverless framework and CloudFormation</li> <li>autoconfiguration for provider specific features (eg. AWS X-Ray, Death Letter Queues, Encryption etc.)</li> <li>function factory for common serverless functions (http, even-bridge, SQS, kinesis)</li> <li>security by default - including encryption, backups and DLQ</li> <li>easier IAM management with predefined permission sets</li> <li>support for multi-region deployments</li> <li>integrations with AWS Power Tools, Sentry</li> <li>naming strategy enforced across all resources</li> <li>support for multi-stack and shared resources</li> <li>automatic alerting </li> <li>support for step functions via (serverless-step-functions)</li> </ul>"},{"location":"#why","title":"Why?","text":"<p>It came to life when we started getting lost in massive (and complex) CloudFormation configuration and had to duplicate YAML modules between our micro services.</p> <p>When we\u2019re starting new micro service we have some preferences in terms of how we want to handle SQS with DLQ, list of plugins we want to use, the way we store params between environments or simple as default tags for our services.</p> <p>Now, imagine that you have this perfect setup in one of your projects, but you need to multiply it by 2, 10, 20, 40\u2026 micro services.</p> <p>So you prepared your YAML modules or some batch scripts. Not super handy nor easily to maintain.</p> <p>Then you realised that your \u201cperfect setup\u201d has a bug. So you have to go through 40 micro services and change CloudFormation in all of them.</p> <p>Wouldn\u2019t it be nice to have it done programmatically in language you like, that is easy to extend, or even executed automatically by your CI/CD process?</p> <p>That\u2019s where <code>serverless-builder</code> becomes handy!</p>"},{"location":"#credits","title":"Credits","text":"<p>Massive thanks goes to @dxd1 for his original idea and implementation.</p> <p><code>serverless-builder</code> is actively developed at Epsy - would you like to change a world with us?  Check our open positions at: https://epsyhealth.com/careers</p>"},{"location":"advanced/","title":"Advanced","text":""},{"location":"advanced/#multi-region-deployments","title":"Multi Region deployments","text":""},{"location":"advanced/#default-values-scope-management","title":"Default values (scope management)","text":"<p>Quite often multiple resources share same set of parameters, good example are layers or auth method shared across multiple functions.</p> <p>For that purpose we have <code>preset</code> function.</p> <pre><code>with service.preset(\n    layers=[{\"Ref\": \"PythonRequirementsLambdaLayer\"}],\n    handler=\"test.handlers.custom_handler.handle\"\n) as p:\n    p.http_get(\"test-list\", \"List all tests\", \"/\")\n    p.http_get(\"test-get\", \"Get one test\", \"/{test_id}\")\n</code></pre> <p>In this case both functions will also have two extra parameters set, <code>layers</code> and <code>handler</code></p>"},{"location":"advanced/#presets","title":"Presets","text":"<p>With your team you can agree on list of plugins, integrations and settings that should be used across multiple repositories (micro services).</p> <p>The easiest way to share those settings is to override default <code>Service</code> class and extract it to separated repository.</p> <pre><code>from serverless import Configuration\nfrom serverless import Service as BaseService\nfrom serverless.aws.features import XRay\nfrom serverless.aws.features.encryption import Encryption\nfrom serverless.aws.provider import Provider as AWSProvider\nfrom serverless.integration.powertools import Powertools\nfrom serverless.integration.sentry import Sentry\nfrom serverless.service.environment import Environment\nfrom serverless.service.plugins.prune import Prune\nfrom serverless.service.plugins.python_requirements import PythonRequirements\n\n\nclass Service(BaseService):\n    yaml_tag = \"!Service\"\n\n    def __init__(self, name: str, description: str, environment=None, sentry_dsn=None, **kwds):\n        defaults = dict(\n            LOG_LEVEL=\"${self:custom.vars.log_level}\",\n            SERVICE=\"${self:service}\",\n            STAGE=\"${sls:stage}\",\n        )\n\n        defaults.update(environment.envs)\n        env = Environment(**defaults)\n\n        super().__init__(\n            name, description, AWSProvider(environment=env), config=Configuration(domain=\"epsy.app\"), **kwds\n        )\n\n        self.plugins.add(Prune())\n        self.plugins.add(PythonRequirements(layer=False))\n\n        if sentry_dsn:\n            self.enable(Sentry(sentry_dsn=sentry_dsn))\n\n        self.enable(XRay())\n        self.enable(Powertools())\n        self.enable(Encryption())\n</code></pre> <p>In your project then you can use your custom <code>Service</code> class.</p>"},{"location":"ci/","title":"CI/CD integration","text":""},{"location":"concept/","title":"Concept","text":""},{"location":"concept/#naming-convention","title":"Naming convention","text":""},{"location":"concept/#supported-platforms","title":"Supported platforms","text":""},{"location":"concept/#alternatives","title":"Alternatives","text":""},{"location":"getting_started/","title":"Getting started","text":""},{"location":"getting_started/#1-install","title":"1. Install","text":"<p>To use stable version use latest version from <code>pypi</code>:</p> <pre><code>$ pip install serverless-builder\n</code></pre>"},{"location":"getting_started/#2-create-serverlessymlpy","title":"2. Create <code>serverless.yml.py</code>","text":"<pre><code>from serverless import Service\nfrom serverless.provider import AWSProvider\n\nservice = Service(\n    \"service-name\",\n    \"Description of my service\",\n    AWSProvider()\n)\n\nservice.render()\n</code></pre>"},{"location":"getting_started/#3-generate-serverlessyml","title":"3. Generate serverless.yml","text":"<pre><code>$ python serverless.yml.py\n</code></pre> <p>Lambda functions <code>serverless-builder</code> allows you easily define different types of lambdas. In many cases it also takes care, by default, for setting up Dead Letter Queue (DLQ) or its asynchronous equivalent, Retry Policy or idempotency.</p> <p><code>serverless-builder</code> will take care of creating any required resources as well as IAM permissions. </p>"},{"location":"features/encryption/","title":"Encryption","text":"<p>One of the core assumption behind serverless-builder was to simplify a process of building reliable and secure services with best practices applied by default - that means full support for encryption at rest and in transit.</p> <p><code>serverless-builder</code> has a built-in support for AWS KMS encryption with per service encryption key.</p> <p>Enabling encryption feature</p> <pre><code>from serverless.service.environment import Environment\nfrom serverless.aws.provider import Provider as AWSProvider\nfrom serverless import Service\nfrom serverless.aws.features.encryption import Encryption\n\nservice = Service(\n    \"serverless-builder-demo\",\n    \"serverless-builder demo service\",\n    environment=Environment(),\n    provider=AWSProvider()\n)\n\nservice.enable(Encryption())\n\nservice.render()\n</code></pre> <p>Importing an Encryption feature will perform a coupe of things: </p> <ol> <li>Create a new Customer managed key with AWS KMS with relevant usage policy (Resource name: <code>ServiceEncryptionKey</code> )</li> <li>Create a new KMS Alias matching <code>alias/${self:service}-${sls:stage}</code> pattern (Resource name: <code>ServiceEncryptionKeyAlias</code>)</li> <li>Import and configure serverless-kms-grants plugin for managing usage permissions on service encryption key</li> </ol> <p>Side effects</p> <p>Each function registered with serverless-builder will be added to <code>serverless-kms-grants</code> plugin configuration without any additional work.</p> <pre><code>service.builder.function.generic(\"show\", \"Show function\")\n</code></pre> <p>will be translated into:</p> <pre><code>  kmsGrants:\n  - kmsKeyId: alias/${self:service}-${sls:stage}\n    roleName: ${self:service}-${sls:stage}-${aws:region}-service-6dbb8\n</code></pre> <p>Please note that IAM roles have autogenerated suffixes to enforce globally unique names.  Please check <code>serverless-builder</code> naming conventions for more details.</p>"},{"location":"features/encryption/#loggroups","title":"LogGroups","text":"<p>By default serverless framework is using unencrypted logs. If you enable Encryption feature <code>serverless-builder</code> will overwrite this behaviour for all registered lambda functions and will enable log encryption with created KMS key.</p>"},{"location":"features/encryption/#secrets","title":"Secrets","text":"<p>If you need to store secrets in your application you should use AWS Secrets Manager, <code>serverless-builder</code> makes this integration much simpler.</p> <pre><code>from serverless.aws.iam.secrets_manager import SecretsManagerReader\nfrom serverless.aws.resources.kms import EncryptableResource\nfrom troposphere.secretsmanager import Secret\n\nsecret = \"/services/${self:service}/${sls:stage}\"\n\nself.provider.iam.apply(SecretsManagerReader(secret))\nself.resources.add(Secret(title=\"ServiceSecret\", KmsKeyId=EncryptableResource.encryption_alias(), Name=secret))\n</code></pre> <p>AWS by default uses default AWS managed KMS key for encrypting secrets, but you can change that behaviour to use service owned encryption key. </p>"},{"location":"features/encryption/#dynamodb","title":"DynamoDB","text":"<p><code>serverless-builder</code> is providing a <code>troposphere</code> compatible <code>DynamoDB</code> resource definition with some extra features including integrated support for server side encryption.</p> <p>Whenever you need to create a new DynamoDB table it\u2019s recommend to use implementation provided by <code>serverless-builder</code></p> <pre><code>from serverless.aws.resources.dynamodb import Table\nfrom troposphere.dynamodb import AttributeDefinition, KeySchema\n\ntable = Table(\n    \"SampleTable\",\n    BillingMode=\"PAY_PER_REQUEST\",\n    AttributeDefinitions=[\n        AttributeDefinition(AttributeName=\"id\", AttributeType=\"S\"),\n    ],\n    KeySchema=[\n        KeySchema(AttributeName=\"id\", KeyType=\"HASH\"),\n    ],\n)\nservice.resources.add(table)\n</code></pre> <p><code>serverless-builder</code> will translate that into a valid table definition with KMS encryption enabled, it will also define <code>DepndsOn</code>  to ensure that table is created after encryption key and aliases are available. </p> <pre><code>    SampleTable:\n      Properties:\n        TableName: ServerlessBuilderDemoSampleTable-${sls:stage}\n        BillingMode: PAY_PER_REQUEST\n        AttributeDefinitions:\n        - AttributeName: id\n          AttributeType: S\n        KeySchema:\n        - AttributeName: id\n          KeyType: HASH\n        PointInTimeRecoverySpecification:\n          PointInTimeRecoveryEnabled: true\n        SSESpecification:\n          SSEEnabled: true\n          SSEType: KMS\n          KMSMasterKeyId:\n            Ref: ServiceEncryptionKey\n      Type: AWS::DynamoDB::Table\n      DeletionPolicy: Retain\n      DependsOn:\n      - ServiceEncryptionKeyAlias\n</code></pre>"},{"location":"features/encryption/#s3-buckets","title":"S3 Buckets","text":"<p><code>serverless-builder</code> is providing a S3 Bucket wrapper which is supporting server side encryption by default, you should use it  whenever you need to create new S3 bucket.</p> <pre><code>from serverless.aws.resources.s3 import S3Bucket\n\nbucket = S3Bucket(\n    \"sample-bucket\"\n)\nservice.resources.add(bucket)\n</code></pre> <p><code>S3Bucket</code> class will automatically take care of setting up encryption for your bucket, and will generate yaml similar to  that one:</p> <pre><code>    SampleBucket:\n      Properties:\n        AccessControl: Private\n        PublicAccessBlockConfiguration:\n          BlockPublicAcls: true\n          BlockPublicPolicy: true\n          IgnorePublicAcls: true\n          RestrictPublicBuckets: true\n        VersioningConfiguration:\n          Status: Enabled\n        BucketName: sample-bucket.${aws:region}.${ssm:/global/primary-domain}\n        BucketEncryption:\n          ServerSideEncryptionConfiguration:\n          - BucketKeyEnabled: true\n            ServerSideEncryptionByDefault:\n              KMSMasterKeyID:\n                Ref: ServiceEncryptionKey\n              SSEAlgorithm: aws:kms\n      Type: AWS::S3::Bucket\n</code></pre>"},{"location":"features/encryption/#kinesis","title":"Kinesis","text":"<p><code>KinesisStream</code> wrapper provided by <code>serverless-builder</code> has as well built-in support for encryption feature detection. All you need to do is to use it instead of default one.</p> <pre><code>from serverless.aws.resources.kinesis import KinesisStream\n\nstream = KinesisStream(\"sample-name\")\nservice.resources.add(stream)\n</code></pre> <p>Generated Yaml syntax <pre><code>    SampleName:\n      Properties:\n        Name: ${self:service}-${sls:stage}-sample-name\n        StreamEncryption:\n          KeyId:\n            Ref: ServiceEncryptionKey\n          EncryptionType: KMS\n      Type: AWS::Kinesis::Stream\n</code></pre></p>"},{"location":"features/plugins/","title":"Plugins","text":"<p><code>serverless-builder</code> has a native support for most common serverless plugins with predefined setup. </p> <p>To activate plugin you just need to add it, with <code>service.plugins.add</code> function.</p> <p>E.g. <pre><code>from serverless.plugins import ComposedVars\n\nservice.plugins.add(ComposedVars())\n</code></pre></p> <p>Majority of plugins is customisable, and during initialization allows you to pass config to itself.</p>"},{"location":"features/plugins/#supported-plugins","title":"Supported plugins","text":""},{"location":"features/plugins/#serverless-aws-signer","title":"serverless-aws-signer","text":"<p>Documentation: https://www.npmjs.com/package/serverless-aws-signer</p>"},{"location":"features/plugins/#default-configuration","title":"Default configuration","text":"<ul> <li><code>sign_policy</code> - \u201cEnforce\u201d</li> <li><code>source_bucket</code> and <code>destination_bucket</code> - configured to use <code>deploymentBucket</code> </li> <li><code>destination_prefix</code> - <code>signed-</code></li> </ul>"},{"location":"features/plugins/#minimal-setup","title":"Minimal setup","text":"<pre><code>from serverless.service.plugins.code_sign import AWSCodeSign\n\nself.plugins.add(\n    AWSCodeSign(\n        \"${ssm:/global/lambda-signing-profile}\",\n    )\n)\n</code></pre>"},{"location":"features/plugins/#serverless-deployment-bucket","title":"serverless-deployment-bucket","text":"<p>Documentation: https://www.npmjs.com/package/serverless-deployment-bucket</p>"},{"location":"features/plugins/#default-configuration_1","title":"Default configuration","text":"<ul> <li><code>bucket_name</code> - name or \u201c${self:provider.deploymentBucket.name}\u201d</li> </ul>"},{"location":"features/plugins/#minimal-setup_1","title":"Minimal setup","text":"<pre><code>from serverless.service.plugins.deployment_bucket import DeploymentBucket\n\nself.plugins.add(DeploymentBucket())\n</code></pre>"},{"location":"features/plugins/#serverless-domain-manager","title":"serverless-domain-manager","text":"<p>Documentation: https://www.serverless.com/plugins/serverless-domain-manager</p>"},{"location":"features/plugins/#default-configuration_2","title":"Default configuration","text":"<ul> <li><code>domain</code> - FQDN used as a base for API gateway</li> <li><code>api</code> - Name of the API</li> </ul>"},{"location":"features/plugins/#minimal-setup_2","title":"Minimal setup","text":"<pre><code>from serverless.service.plugins.domain_manager import DomainManager\n\nself.plugins.add(DomainManager(domain=\"example.com\"))\n</code></pre>"},{"location":"features/plugins/#serverless-iam-roles-per-function","title":"serverless-iam-roles-per-function","text":""},{"location":"features/plugins/#serverless-prune-plugin","title":"serverless-prune-plugin","text":""},{"location":"features/plugins/#serverless-python-requirements","title":"serverless-python-requirements","text":""},{"location":"features/plugins/#serverless-scriptable-plugin","title":"serverless-scriptable-plugin","text":""},{"location":"features/plugins/#serverless-secrets-mgr-plugin","title":"serverless-secrets-mgr-plugin","text":""},{"location":"features/plugins/#serverless-step-functions","title":"serverless-step-functions","text":""},{"location":"features/plugins/#serverless-vpc-discovery","title":"serverless-vpc-discovery","text":""},{"location":"integrations/power_tools/","title":"AWS Lambda Power Tools","text":""},{"location":"integrations/power_tools/#aws-lambda-powertools-python","title":"AWS Lambda Powertools Python","text":"<p>AWS Lambda Powertools is great tool! If you haven\u2019t used it yet have a look! <code>serverless-builder</code> integrates with it in few places</p>"},{"location":"integrations/power_tools/#enable-it","title":"Enable it","text":"<pre><code>from serverless.integration.powertools import Powertools\n\nservice.enable(Powertools())\n</code></pre>"},{"location":"integrations/power_tools/#automatically-sets-env-variables","title":"Automatically sets ENV variables","text":"<p>It will set <code>POWERTOOLS_SERVICE_NAME</code> and <code>POWERTOOLS_LOGGER_LOG_EVENT</code> ENV variables.</p>"},{"location":"integrations/power_tools/#creates-idempotency-dynamodb-table","title":"Creates idempotency DynamoDB table","text":"<p>To be able to use idempotency you need to create separated DynamoDB table for your service.</p> <p><code>with_idempotency</code> function allows you to create both, dynamodb table, and set correct IAM permissions for it.</p> <p>You can use it for any lambda function.</p> <pre><code># example of use with `http_get`\nservice.builder.function.http_get(\n    \"test-list\", \n    \"List all tests\", \n    \"/\"\n).with_idempotency()\n</code></pre> <p>It will generate following YAML <pre><code>service: service-name\nprovider:\n...\n  iam:\n    role:\n      statements:\n      - Sid: ServiceNameTestListIdempotencyFullAccess\n        Effect: Allow\n        Action:\n        - dynamodb:BatchGetItem\n        - dynamodb:GetItem\n        - dynamodb:Query\n        - dynamodb:Scan\n        - dynamodb:BatchWriteItem\n        - dynamodb:DeleteItem\n        - dynamodb:UpdateItem\n        - dynamodb:PutItem\n        Resource:\n        - Fn::GetAtt:\n          - ServiceNameTestListIdempotency\n          - Arn\n      name: ${self:service}-${sls:stage}-${aws:region}-service\n\nfunctions:\n  TestList:\n    name: service-name-${sls:stage}-test-list\n    description: List all tests\n    handler: service_name.test-list.handler\n    events:\n    - http:\n        path: /\n        method: GET\n    environment:\n      IDEMPOTENCY_TABLE:\n        Ref: ServiceNameTestListIdempotency\n\nresources:\n...\n    ServiceNameTestListIdempotency:\n      Properties:\n        TableName: ServiceName${sls:stage}TestListIdempotency\n        BillingMode: PAY_PER_REQUEST\n        AttributeDefinitions:\n        - AttributeName: id\n          AttributeType: S\n        KeySchema:\n        - AttributeName: id\n          KeyType: HASH\n        TimeToLiveSpecification:\n          AttributeName: expiration\n          Enabled: true\n        PointInTimeRecoverySpecification:\n          PointInTimeRecoveryEnabled: true\n      Type: AWS::DynamoDB::Table\n      DeletionPolicy: Retain\n</code></pre></p> Info: You can use it without enabling integration <p>Running <code>service.enable(Powertools())</code> is not required but highly recommended</p> Warning: You still need to setup your lambda to use idempotency <p>You still need to follow idempotency configuration for your lambda to use this table</p>"},{"location":"integrations/sentry/","title":"Sentry","text":""},{"location":"integrations/sentry/#enable-it","title":"Enable it","text":"<pre><code>from serverless.integration.sentry import Sentry\n\nservice.enable(Sentry(\"https://xxxx-yyyy-zzzzz-wwwww.ingest.sentry.io/123456789\"))\n</code></pre>"},{"location":"integrations/sentry/#automatically-sets-env-variables","title":"Automatically sets ENV variables","text":"<p>It will automatically set <code>SENTRY_DSN</code>, <code>SENTRY_ENVIRONMENT</code> and <code>SENTRY_RELEASE</code>.</p> You need to provide value for <code>VERSION</code> environment variable during the deployment to use release features of sentry."},{"location":"integrations/step_functions/","title":"Step functions","text":"<p><code>serverless-builder</code> have a built-in support for serverless-step-functions which allows for a faster and more comprehensive development of complex workflows with AWS Step Functions </p> <p><code>serverless-builder</code> provides a programming interface for building a complex workflows using serverless lambda functions  with some extra features like: * autogeneration of the state names * auto tracking of the dependencies (automatically setting up )</p> <pre><code>from serverless.aws.features.stepfunctions import Branch, Choice, Iterator, Map, Scheduled, Succeed, Task\n\nget_all_users = service.builder.function.generic(\n    \"get_all_users\",\n    \"Returns with all users (for scheduling tasks)\",\n    \"task_service.handler.get_all_users\",\n)\n\nweekly_task = service.builder.function.generic(\n    \"weekly_task\",\n    \"Schedules tasks for a user on each week\",\n    \"task_service.handler.weekly_tasks\",\n    timeout=30,\n)\n\nmachine = service.stepFunctions.machine(\"Weekly\", \"\", type=\"EXPRESS\", auto_fallback=False, auto_catch=False)\ntask = machine.task(get_all_users)\ntask.next(\n    machine.parallel(\n        name=\"ProcessAndContinue\",\n        branches=[\n            Branch(\n                Map(\n                    name=\"ProcessUser\",\n                    items_path=\"$.user_ids\",\n                    result_path=None,\n                    input_path=None,\n                    concurrency=1,\n                    end=True,\n                    steps=Iterator(\n                        map_name=\"ProcessUser\",\n                        steps=[Task(name=\"ProcessFunction\", end=True, function=weekly_task)],\n                        auto_catch=False,\n                        auto_fallback=False,\n                    ),\n                )\n            ),\n            Branch(\n                Choice(\n                    name=\"ContinueIfMoreUsers\",\n                    default=\"NoMoreUsers\",\n                    choices=[dict(IsPresent=True, Next=\"Restart\", Variable=\"$.PaginationToken\")],\n                ),\n                Succeed(name=\"NoMoreUsers\"),\n                Task(\n                    name=\"Restart\",\n                    end=True,\n                    parameters=dict(\n                        Input={\"PaginationToken.$\": \"$.PaginationToken\"}, StateMachineArn=machine.arn()\n                    ),\n                    resource=\"arn:aws:states:::states:startExecution\",\n                ),\n            ),\n        ],\n        end=True,\n    )\n)\n\nmachine.event(Scheduled(\"0 18 ? * SAT *\", dict(start=\"true\")))\n</code></pre> <p>Sample workflow generated with serverless  </p> <pre><code>stepFunctions:\n  validate: true\n  stateMachines:\n    Weekly:\n      name: task-service-${sls:stage}-Weekly\n      tracingConfig:\n        enabled: true\n      type: EXPRESS\n      loggingConfig:\n        level: ERROR\n        includeExecutionData: true\n        destinations:\n        - Fn::GetAtt:\n          - StepmachineTaskServiceWeeklyLogGroup\n          - Arn\n      definition:\n        StartAt: GetAllUsers\n        Comment: ''\n        States:\n          GetAllUsers:\n            Type: Task\n            Resource:\n              Fn::GetAtt:\n              - GetAllUsersLambdaFunction\n              - Arn\n            Next: ProcessAndContinue\n          ProcessAndContinue:\n            Type: Parallel\n            Branches:\n            - StartAt: ProcessUser\n              States:\n                ProcessUser:\n                  Type: Map\n                  ItemsPath: $.user_ids\n                  MaxConcurrency: 1\n                  End: true\n                  Iterator:\n                    StartAt: ProcessFunction\n                    States:\n                      ProcessFunction:\n                        Type: Task\n                        Resource:\n                          Fn::GetAtt:\n                          - WeeklyTaskLambdaFunction\n                          - Arn\n                        End: true\n            - StartAt: ContinueIfMoreUsers\n              States:\n                ContinueIfMoreUsers:\n                  Type: Choice\n                  Default: NoMoreUsers\n                  Choices:\n                  - IsPresent: true\n                    Next: Restart\n                    Variable: $.PaginationToken\n                NoMoreUsers:\n                  Type: Succeed\n                Restart:\n                  Type: Task\n                  Parameters:\n                    Input:\n                      PaginationToken.$: $.PaginationToken\n                    StateMachineArn: arn:aws:states:${aws:region}:${aws:accountId}:stateMachine:task-service-${sls:stage}-Weekly\n                  Resource: arn:aws:states:::states:startExecution\n                  End: true\n            End: true\n      events:\n      - schedule:\n          rate: cron(0 18 ? * SAT *)\n        inputPath:\n          start: 'true'\n</code></pre>"},{"location":"resources/functions/","title":"Functions","text":"<p><code>serverless-builder</code> has a built-in support for common lambda functions with best practices applied by default.</p>"},{"location":"resources/functions/#http","title":"HTTP","text":"<p>There are two ways of generating HTTP endpoint. You can use one of the helper functions e.g. <code>http_get</code>, <code>http_post</code>, or just more generic <code>http</code> with passed explicitly HTTP method.</p> <pre><code>from serverless.aws.functions.http import HTTPFunction\n\nservice.builder.function.http_get(\"test-list\", \"List all tests\", \"/\")\nservice.builder.function.http_post(\"test-list\", \"List all tests\", \"/\")\nservice.builder.function.http_put(\"test-list\", \"List all tests\", \"/\")\nservice.builder.function.http_patch(\"test-list\", \"List all tests\", \"/\")\nservice.builder.function.http_delete(\"test-list\", \"List all tests\", \"/\")\nservice.builder.function.http_options(\"test-list\", \"List all tests\", \"/\")\nservice.builder.function.http_any(\"test-list\", \"List all tests\", \"/\")\nservice.builder.function.http(\"test\", \"description\", \"/\", HTTPFunction.POST)\n</code></pre> <p>Call to any of the above functions will generate serverless.com function with its corresponding HTTP event e.g.: <pre><code>functions:\n  Test:\n    name: service-name-${sls:stage}-test\n    description: description\n    handler: service_name.test.handler\n    events:\n    - http:\n        path: /\n        method: POST\n</code></pre></p>"},{"location":"resources/functions/#eventbridge","title":"EventBridge","text":"<pre><code>service.builder.function.event_bridge(\n    \"event_bridge_function\",\n    \"sample event bridge function\",\n    \"epsy\",\n    {\"source\": [\"saas.external\"]},\n)\n</code></pre>"},{"location":"resources/functions/#with-dlq","title":"With DLQ","text":"<p>By default <code>function.event_bridge</code> will setup DLQ for your lambda that processes EventBridge messages.</p>"},{"location":"resources/functions/#s3","title":"S3","text":"<pre><code>service.builder.function.s3(\n        \"Reload\",\n        \"Reloads list of IDs\",\n        timeout=30,\n        bucket=\"${self:service}.${ssm:/global/primary-domain}\",\n        event=\"s3:ObjectCreated:*\",\n        rules=[{\"prefix\": \"list/ids\"}],\n    )\n</code></pre>"},{"location":"resources/functions/#websockets","title":"Websockets","text":"<pre><code>from serverless.aws.functions.websocket import WebsocketEvent, Authorizer as WebsocketEventAuthorizer\n\n\nservice.builder.function.websocket(\n    \"handler_connect\",\n    \"Handles client opening Websocket connection\",\n    events=[WebsocketEvent(route=\"$connect\", authorizer=WebsocketEventAuthorizer(\"HandleAuthorization\"))],\n    handler=\"my_module.handler.handle_connect\",\n)\n</code></pre>"},{"location":"resources/functions/#generic","title":"Generic","text":"<pre><code>service.builder.function.generic(\n    \"my-generic-function\",\n    \"Handle internal calls\",\n    handler=\"my_project.my_module.handler\",\n\n    # By default every function has LogGroup created by `serverless-builder`\n    # but sometimes you have to customise it, for that you can use `log_group`\n    log_group=dict(\n        DeletionPolicy=\"Retain\",\n        Properties=dict(\n            RetentionInDays=3653,\n        )\n    )\n)\n</code></pre>"}]}